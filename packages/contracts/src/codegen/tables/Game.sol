// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/* Autogenerated file. Do not edit manually. */

// Import schema type
import { SchemaType } from "@latticexyz/schema-type/src/solidity/SchemaType.sol";

// Import store internals
import { IStore } from "@latticexyz/store/src/IStore.sol";
import { StoreSwitch } from "@latticexyz/store/src/StoreSwitch.sol";
import { StoreCore } from "@latticexyz/store/src/StoreCore.sol";
import { Bytes } from "@latticexyz/store/src/Bytes.sol";
import { Memory } from "@latticexyz/store/src/Memory.sol";
import { SliceLib } from "@latticexyz/store/src/Slice.sol";
import { EncodeArray } from "@latticexyz/store/src/tightcoder/EncodeArray.sol";
import { Schema, SchemaLib } from "@latticexyz/store/src/Schema.sol";
import { PackedCounter, PackedCounterLib } from "@latticexyz/store/src/PackedCounter.sol";

bytes32 constant _tableId = bytes32(abi.encodePacked(bytes16(""), bytes16("Game")));
bytes32 constant GameTableId = _tableId;

struct GameData {
  bytes32 crime;
  address player;
  bool isGuilty;
  string openingStatement;
  string closingStatement;
  string victimQuestionOne;
  string victimQuestionTwo;
  string victimQuestionThree;
  string victimAnswerOne;
  string victimAnswerTwo;
  string victimAnswerThree;
  string verdict;
}

library Game {
  /** Get the table's schema */
  function getSchema() internal pure returns (Schema) {
    SchemaType[] memory _schema = new SchemaType[](12);
    _schema[0] = SchemaType.BYTES32;
    _schema[1] = SchemaType.ADDRESS;
    _schema[2] = SchemaType.BOOL;
    _schema[3] = SchemaType.STRING;
    _schema[4] = SchemaType.STRING;
    _schema[5] = SchemaType.STRING;
    _schema[6] = SchemaType.STRING;
    _schema[7] = SchemaType.STRING;
    _schema[8] = SchemaType.STRING;
    _schema[9] = SchemaType.STRING;
    _schema[10] = SchemaType.STRING;
    _schema[11] = SchemaType.STRING;

    return SchemaLib.encode(_schema);
  }

  function getKeySchema() internal pure returns (Schema) {
    SchemaType[] memory _schema = new SchemaType[](1);
    _schema[0] = SchemaType.BYTES32;

    return SchemaLib.encode(_schema);
  }

  /** Get the table's metadata */
  function getMetadata() internal pure returns (string memory, string[] memory) {
    string[] memory _fieldNames = new string[](12);
    _fieldNames[0] = "crime";
    _fieldNames[1] = "player";
    _fieldNames[2] = "isGuilty";
    _fieldNames[3] = "openingStatement";
    _fieldNames[4] = "closingStatement";
    _fieldNames[5] = "victimQuestionOne";
    _fieldNames[6] = "victimQuestionTwo";
    _fieldNames[7] = "victimQuestionThree";
    _fieldNames[8] = "victimAnswerOne";
    _fieldNames[9] = "victimAnswerTwo";
    _fieldNames[10] = "victimAnswerThree";
    _fieldNames[11] = "verdict";
    return ("Game", _fieldNames);
  }

  /** Register the table's schema */
  function registerSchema() internal {
    StoreSwitch.registerSchema(_tableId, getSchema(), getKeySchema());
  }

  /** Register the table's schema (using the specified store) */
  function registerSchema(IStore _store) internal {
    _store.registerSchema(_tableId, getSchema(), getKeySchema());
  }

  /** Set the table's metadata */
  function setMetadata() internal {
    (string memory _tableName, string[] memory _fieldNames) = getMetadata();
    StoreSwitch.setMetadata(_tableId, _tableName, _fieldNames);
  }

  /** Set the table's metadata (using the specified store) */
  function setMetadata(IStore _store) internal {
    (string memory _tableName, string[] memory _fieldNames) = getMetadata();
    _store.setMetadata(_tableId, _tableName, _fieldNames);
  }

  /** Get crime */
  function getCrime(bytes32 id) internal view returns (bytes32 crime) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 0);
    return (Bytes.slice32(_blob, 0));
  }

  /** Get crime (using the specified store) */
  function getCrime(IStore _store, bytes32 id) internal view returns (bytes32 crime) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 0);
    return (Bytes.slice32(_blob, 0));
  }

  /** Set crime */
  function setCrime(bytes32 id, bytes32 crime) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.setField(_tableId, _keyTuple, 0, abi.encodePacked((crime)));
  }

  /** Set crime (using the specified store) */
  function setCrime(IStore _store, bytes32 id, bytes32 crime) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.setField(_tableId, _keyTuple, 0, abi.encodePacked((crime)));
  }

  /** Get player */
  function getPlayer(bytes32 id) internal view returns (address player) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 1);
    return (address(Bytes.slice20(_blob, 0)));
  }

  /** Get player (using the specified store) */
  function getPlayer(IStore _store, bytes32 id) internal view returns (address player) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 1);
    return (address(Bytes.slice20(_blob, 0)));
  }

  /** Set player */
  function setPlayer(bytes32 id, address player) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.setField(_tableId, _keyTuple, 1, abi.encodePacked((player)));
  }

  /** Set player (using the specified store) */
  function setPlayer(IStore _store, bytes32 id, address player) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.setField(_tableId, _keyTuple, 1, abi.encodePacked((player)));
  }

  /** Get isGuilty */
  function getIsGuilty(bytes32 id) internal view returns (bool isGuilty) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 2);
    return (_toBool(uint8(Bytes.slice1(_blob, 0))));
  }

  /** Get isGuilty (using the specified store) */
  function getIsGuilty(IStore _store, bytes32 id) internal view returns (bool isGuilty) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 2);
    return (_toBool(uint8(Bytes.slice1(_blob, 0))));
  }

  /** Set isGuilty */
  function setIsGuilty(bytes32 id, bool isGuilty) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.setField(_tableId, _keyTuple, 2, abi.encodePacked((isGuilty)));
  }

  /** Set isGuilty (using the specified store) */
  function setIsGuilty(IStore _store, bytes32 id, bool isGuilty) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.setField(_tableId, _keyTuple, 2, abi.encodePacked((isGuilty)));
  }

  /** Get openingStatement */
  function getOpeningStatement(bytes32 id) internal view returns (string memory openingStatement) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 3);
    return (string(_blob));
  }

  /** Get openingStatement (using the specified store) */
  function getOpeningStatement(IStore _store, bytes32 id) internal view returns (string memory openingStatement) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 3);
    return (string(_blob));
  }

  /** Set openingStatement */
  function setOpeningStatement(bytes32 id, string memory openingStatement) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.setField(_tableId, _keyTuple, 3, bytes((openingStatement)));
  }

  /** Set openingStatement (using the specified store) */
  function setOpeningStatement(IStore _store, bytes32 id, string memory openingStatement) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.setField(_tableId, _keyTuple, 3, bytes((openingStatement)));
  }

  /** Get the length of openingStatement */
  function lengthOpeningStatement(bytes32 id) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    uint256 _byteLength = StoreSwitch.getFieldLength(_tableId, _keyTuple, 3, getSchema());
    return _byteLength / 1;
  }

  /** Get the length of openingStatement (using the specified store) */
  function lengthOpeningStatement(IStore _store, bytes32 id) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    uint256 _byteLength = _store.getFieldLength(_tableId, _keyTuple, 3, getSchema());
    return _byteLength / 1;
  }

  /** Get an item of openingStatement (unchecked, returns invalid data if index overflows) */
  function getItemOpeningStatement(bytes32 id, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getFieldSlice(_tableId, _keyTuple, 3, getSchema(), _index * 1, (_index + 1) * 1);
    return (string(_blob));
  }

  /** Get an item of openingStatement (using the specified store) (unchecked, returns invalid data if index overflows) */
  function getItemOpeningStatement(IStore _store, bytes32 id, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getFieldSlice(_tableId, _keyTuple, 3, getSchema(), _index * 1, (_index + 1) * 1);
    return (string(_blob));
  }

  /** Push a slice to openingStatement */
  function pushOpeningStatement(bytes32 id, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.pushToField(_tableId, _keyTuple, 3, bytes((_slice)));
  }

  /** Push a slice to openingStatement (using the specified store) */
  function pushOpeningStatement(IStore _store, bytes32 id, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.pushToField(_tableId, _keyTuple, 3, bytes((_slice)));
  }

  /** Pop a slice from openingStatement */
  function popOpeningStatement(bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.popFromField(_tableId, _keyTuple, 3, 1);
  }

  /** Pop a slice from openingStatement (using the specified store) */
  function popOpeningStatement(IStore _store, bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.popFromField(_tableId, _keyTuple, 3, 1);
  }

  /** Update a slice of openingStatement at `_index` */
  function updateOpeningStatement(bytes32 id, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.updateInField(_tableId, _keyTuple, 3, _index * 1, bytes((_slice)));
  }

  /** Update a slice of openingStatement (using the specified store) at `_index` */
  function updateOpeningStatement(IStore _store, bytes32 id, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.updateInField(_tableId, _keyTuple, 3, _index * 1, bytes((_slice)));
  }

  /** Get closingStatement */
  function getClosingStatement(bytes32 id) internal view returns (string memory closingStatement) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 4);
    return (string(_blob));
  }

  /** Get closingStatement (using the specified store) */
  function getClosingStatement(IStore _store, bytes32 id) internal view returns (string memory closingStatement) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 4);
    return (string(_blob));
  }

  /** Set closingStatement */
  function setClosingStatement(bytes32 id, string memory closingStatement) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.setField(_tableId, _keyTuple, 4, bytes((closingStatement)));
  }

  /** Set closingStatement (using the specified store) */
  function setClosingStatement(IStore _store, bytes32 id, string memory closingStatement) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.setField(_tableId, _keyTuple, 4, bytes((closingStatement)));
  }

  /** Get the length of closingStatement */
  function lengthClosingStatement(bytes32 id) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    uint256 _byteLength = StoreSwitch.getFieldLength(_tableId, _keyTuple, 4, getSchema());
    return _byteLength / 1;
  }

  /** Get the length of closingStatement (using the specified store) */
  function lengthClosingStatement(IStore _store, bytes32 id) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    uint256 _byteLength = _store.getFieldLength(_tableId, _keyTuple, 4, getSchema());
    return _byteLength / 1;
  }

  /** Get an item of closingStatement (unchecked, returns invalid data if index overflows) */
  function getItemClosingStatement(bytes32 id, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getFieldSlice(_tableId, _keyTuple, 4, getSchema(), _index * 1, (_index + 1) * 1);
    return (string(_blob));
  }

  /** Get an item of closingStatement (using the specified store) (unchecked, returns invalid data if index overflows) */
  function getItemClosingStatement(IStore _store, bytes32 id, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getFieldSlice(_tableId, _keyTuple, 4, getSchema(), _index * 1, (_index + 1) * 1);
    return (string(_blob));
  }

  /** Push a slice to closingStatement */
  function pushClosingStatement(bytes32 id, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.pushToField(_tableId, _keyTuple, 4, bytes((_slice)));
  }

  /** Push a slice to closingStatement (using the specified store) */
  function pushClosingStatement(IStore _store, bytes32 id, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.pushToField(_tableId, _keyTuple, 4, bytes((_slice)));
  }

  /** Pop a slice from closingStatement */
  function popClosingStatement(bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.popFromField(_tableId, _keyTuple, 4, 1);
  }

  /** Pop a slice from closingStatement (using the specified store) */
  function popClosingStatement(IStore _store, bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.popFromField(_tableId, _keyTuple, 4, 1);
  }

  /** Update a slice of closingStatement at `_index` */
  function updateClosingStatement(bytes32 id, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.updateInField(_tableId, _keyTuple, 4, _index * 1, bytes((_slice)));
  }

  /** Update a slice of closingStatement (using the specified store) at `_index` */
  function updateClosingStatement(IStore _store, bytes32 id, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.updateInField(_tableId, _keyTuple, 4, _index * 1, bytes((_slice)));
  }

  /** Get victimQuestionOne */
  function getVictimQuestionOne(bytes32 id) internal view returns (string memory victimQuestionOne) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 5);
    return (string(_blob));
  }

  /** Get victimQuestionOne (using the specified store) */
  function getVictimQuestionOne(IStore _store, bytes32 id) internal view returns (string memory victimQuestionOne) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 5);
    return (string(_blob));
  }

  /** Set victimQuestionOne */
  function setVictimQuestionOne(bytes32 id, string memory victimQuestionOne) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.setField(_tableId, _keyTuple, 5, bytes((victimQuestionOne)));
  }

  /** Set victimQuestionOne (using the specified store) */
  function setVictimQuestionOne(IStore _store, bytes32 id, string memory victimQuestionOne) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.setField(_tableId, _keyTuple, 5, bytes((victimQuestionOne)));
  }

  /** Get the length of victimQuestionOne */
  function lengthVictimQuestionOne(bytes32 id) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    uint256 _byteLength = StoreSwitch.getFieldLength(_tableId, _keyTuple, 5, getSchema());
    return _byteLength / 1;
  }

  /** Get the length of victimQuestionOne (using the specified store) */
  function lengthVictimQuestionOne(IStore _store, bytes32 id) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    uint256 _byteLength = _store.getFieldLength(_tableId, _keyTuple, 5, getSchema());
    return _byteLength / 1;
  }

  /** Get an item of victimQuestionOne (unchecked, returns invalid data if index overflows) */
  function getItemVictimQuestionOne(bytes32 id, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getFieldSlice(_tableId, _keyTuple, 5, getSchema(), _index * 1, (_index + 1) * 1);
    return (string(_blob));
  }

  /** Get an item of victimQuestionOne (using the specified store) (unchecked, returns invalid data if index overflows) */
  function getItemVictimQuestionOne(IStore _store, bytes32 id, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getFieldSlice(_tableId, _keyTuple, 5, getSchema(), _index * 1, (_index + 1) * 1);
    return (string(_blob));
  }

  /** Push a slice to victimQuestionOne */
  function pushVictimQuestionOne(bytes32 id, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.pushToField(_tableId, _keyTuple, 5, bytes((_slice)));
  }

  /** Push a slice to victimQuestionOne (using the specified store) */
  function pushVictimQuestionOne(IStore _store, bytes32 id, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.pushToField(_tableId, _keyTuple, 5, bytes((_slice)));
  }

  /** Pop a slice from victimQuestionOne */
  function popVictimQuestionOne(bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.popFromField(_tableId, _keyTuple, 5, 1);
  }

  /** Pop a slice from victimQuestionOne (using the specified store) */
  function popVictimQuestionOne(IStore _store, bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.popFromField(_tableId, _keyTuple, 5, 1);
  }

  /** Update a slice of victimQuestionOne at `_index` */
  function updateVictimQuestionOne(bytes32 id, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.updateInField(_tableId, _keyTuple, 5, _index * 1, bytes((_slice)));
  }

  /** Update a slice of victimQuestionOne (using the specified store) at `_index` */
  function updateVictimQuestionOne(IStore _store, bytes32 id, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.updateInField(_tableId, _keyTuple, 5, _index * 1, bytes((_slice)));
  }

  /** Get victimQuestionTwo */
  function getVictimQuestionTwo(bytes32 id) internal view returns (string memory victimQuestionTwo) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 6);
    return (string(_blob));
  }

  /** Get victimQuestionTwo (using the specified store) */
  function getVictimQuestionTwo(IStore _store, bytes32 id) internal view returns (string memory victimQuestionTwo) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 6);
    return (string(_blob));
  }

  /** Set victimQuestionTwo */
  function setVictimQuestionTwo(bytes32 id, string memory victimQuestionTwo) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.setField(_tableId, _keyTuple, 6, bytes((victimQuestionTwo)));
  }

  /** Set victimQuestionTwo (using the specified store) */
  function setVictimQuestionTwo(IStore _store, bytes32 id, string memory victimQuestionTwo) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.setField(_tableId, _keyTuple, 6, bytes((victimQuestionTwo)));
  }

  /** Get the length of victimQuestionTwo */
  function lengthVictimQuestionTwo(bytes32 id) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    uint256 _byteLength = StoreSwitch.getFieldLength(_tableId, _keyTuple, 6, getSchema());
    return _byteLength / 1;
  }

  /** Get the length of victimQuestionTwo (using the specified store) */
  function lengthVictimQuestionTwo(IStore _store, bytes32 id) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    uint256 _byteLength = _store.getFieldLength(_tableId, _keyTuple, 6, getSchema());
    return _byteLength / 1;
  }

  /** Get an item of victimQuestionTwo (unchecked, returns invalid data if index overflows) */
  function getItemVictimQuestionTwo(bytes32 id, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getFieldSlice(_tableId, _keyTuple, 6, getSchema(), _index * 1, (_index + 1) * 1);
    return (string(_blob));
  }

  /** Get an item of victimQuestionTwo (using the specified store) (unchecked, returns invalid data if index overflows) */
  function getItemVictimQuestionTwo(IStore _store, bytes32 id, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getFieldSlice(_tableId, _keyTuple, 6, getSchema(), _index * 1, (_index + 1) * 1);
    return (string(_blob));
  }

  /** Push a slice to victimQuestionTwo */
  function pushVictimQuestionTwo(bytes32 id, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.pushToField(_tableId, _keyTuple, 6, bytes((_slice)));
  }

  /** Push a slice to victimQuestionTwo (using the specified store) */
  function pushVictimQuestionTwo(IStore _store, bytes32 id, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.pushToField(_tableId, _keyTuple, 6, bytes((_slice)));
  }

  /** Pop a slice from victimQuestionTwo */
  function popVictimQuestionTwo(bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.popFromField(_tableId, _keyTuple, 6, 1);
  }

  /** Pop a slice from victimQuestionTwo (using the specified store) */
  function popVictimQuestionTwo(IStore _store, bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.popFromField(_tableId, _keyTuple, 6, 1);
  }

  /** Update a slice of victimQuestionTwo at `_index` */
  function updateVictimQuestionTwo(bytes32 id, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.updateInField(_tableId, _keyTuple, 6, _index * 1, bytes((_slice)));
  }

  /** Update a slice of victimQuestionTwo (using the specified store) at `_index` */
  function updateVictimQuestionTwo(IStore _store, bytes32 id, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.updateInField(_tableId, _keyTuple, 6, _index * 1, bytes((_slice)));
  }

  /** Get victimQuestionThree */
  function getVictimQuestionThree(bytes32 id) internal view returns (string memory victimQuestionThree) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 7);
    return (string(_blob));
  }

  /** Get victimQuestionThree (using the specified store) */
  function getVictimQuestionThree(IStore _store, bytes32 id) internal view returns (string memory victimQuestionThree) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 7);
    return (string(_blob));
  }

  /** Set victimQuestionThree */
  function setVictimQuestionThree(bytes32 id, string memory victimQuestionThree) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.setField(_tableId, _keyTuple, 7, bytes((victimQuestionThree)));
  }

  /** Set victimQuestionThree (using the specified store) */
  function setVictimQuestionThree(IStore _store, bytes32 id, string memory victimQuestionThree) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.setField(_tableId, _keyTuple, 7, bytes((victimQuestionThree)));
  }

  /** Get the length of victimQuestionThree */
  function lengthVictimQuestionThree(bytes32 id) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    uint256 _byteLength = StoreSwitch.getFieldLength(_tableId, _keyTuple, 7, getSchema());
    return _byteLength / 1;
  }

  /** Get the length of victimQuestionThree (using the specified store) */
  function lengthVictimQuestionThree(IStore _store, bytes32 id) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    uint256 _byteLength = _store.getFieldLength(_tableId, _keyTuple, 7, getSchema());
    return _byteLength / 1;
  }

  /** Get an item of victimQuestionThree (unchecked, returns invalid data if index overflows) */
  function getItemVictimQuestionThree(bytes32 id, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getFieldSlice(_tableId, _keyTuple, 7, getSchema(), _index * 1, (_index + 1) * 1);
    return (string(_blob));
  }

  /** Get an item of victimQuestionThree (using the specified store) (unchecked, returns invalid data if index overflows) */
  function getItemVictimQuestionThree(IStore _store, bytes32 id, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getFieldSlice(_tableId, _keyTuple, 7, getSchema(), _index * 1, (_index + 1) * 1);
    return (string(_blob));
  }

  /** Push a slice to victimQuestionThree */
  function pushVictimQuestionThree(bytes32 id, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.pushToField(_tableId, _keyTuple, 7, bytes((_slice)));
  }

  /** Push a slice to victimQuestionThree (using the specified store) */
  function pushVictimQuestionThree(IStore _store, bytes32 id, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.pushToField(_tableId, _keyTuple, 7, bytes((_slice)));
  }

  /** Pop a slice from victimQuestionThree */
  function popVictimQuestionThree(bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.popFromField(_tableId, _keyTuple, 7, 1);
  }

  /** Pop a slice from victimQuestionThree (using the specified store) */
  function popVictimQuestionThree(IStore _store, bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.popFromField(_tableId, _keyTuple, 7, 1);
  }

  /** Update a slice of victimQuestionThree at `_index` */
  function updateVictimQuestionThree(bytes32 id, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.updateInField(_tableId, _keyTuple, 7, _index * 1, bytes((_slice)));
  }

  /** Update a slice of victimQuestionThree (using the specified store) at `_index` */
  function updateVictimQuestionThree(IStore _store, bytes32 id, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.updateInField(_tableId, _keyTuple, 7, _index * 1, bytes((_slice)));
  }

  /** Get victimAnswerOne */
  function getVictimAnswerOne(bytes32 id) internal view returns (string memory victimAnswerOne) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 8);
    return (string(_blob));
  }

  /** Get victimAnswerOne (using the specified store) */
  function getVictimAnswerOne(IStore _store, bytes32 id) internal view returns (string memory victimAnswerOne) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 8);
    return (string(_blob));
  }

  /** Set victimAnswerOne */
  function setVictimAnswerOne(bytes32 id, string memory victimAnswerOne) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.setField(_tableId, _keyTuple, 8, bytes((victimAnswerOne)));
  }

  /** Set victimAnswerOne (using the specified store) */
  function setVictimAnswerOne(IStore _store, bytes32 id, string memory victimAnswerOne) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.setField(_tableId, _keyTuple, 8, bytes((victimAnswerOne)));
  }

  /** Get the length of victimAnswerOne */
  function lengthVictimAnswerOne(bytes32 id) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    uint256 _byteLength = StoreSwitch.getFieldLength(_tableId, _keyTuple, 8, getSchema());
    return _byteLength / 1;
  }

  /** Get the length of victimAnswerOne (using the specified store) */
  function lengthVictimAnswerOne(IStore _store, bytes32 id) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    uint256 _byteLength = _store.getFieldLength(_tableId, _keyTuple, 8, getSchema());
    return _byteLength / 1;
  }

  /** Get an item of victimAnswerOne (unchecked, returns invalid data if index overflows) */
  function getItemVictimAnswerOne(bytes32 id, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getFieldSlice(_tableId, _keyTuple, 8, getSchema(), _index * 1, (_index + 1) * 1);
    return (string(_blob));
  }

  /** Get an item of victimAnswerOne (using the specified store) (unchecked, returns invalid data if index overflows) */
  function getItemVictimAnswerOne(IStore _store, bytes32 id, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getFieldSlice(_tableId, _keyTuple, 8, getSchema(), _index * 1, (_index + 1) * 1);
    return (string(_blob));
  }

  /** Push a slice to victimAnswerOne */
  function pushVictimAnswerOne(bytes32 id, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.pushToField(_tableId, _keyTuple, 8, bytes((_slice)));
  }

  /** Push a slice to victimAnswerOne (using the specified store) */
  function pushVictimAnswerOne(IStore _store, bytes32 id, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.pushToField(_tableId, _keyTuple, 8, bytes((_slice)));
  }

  /** Pop a slice from victimAnswerOne */
  function popVictimAnswerOne(bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.popFromField(_tableId, _keyTuple, 8, 1);
  }

  /** Pop a slice from victimAnswerOne (using the specified store) */
  function popVictimAnswerOne(IStore _store, bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.popFromField(_tableId, _keyTuple, 8, 1);
  }

  /** Update a slice of victimAnswerOne at `_index` */
  function updateVictimAnswerOne(bytes32 id, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.updateInField(_tableId, _keyTuple, 8, _index * 1, bytes((_slice)));
  }

  /** Update a slice of victimAnswerOne (using the specified store) at `_index` */
  function updateVictimAnswerOne(IStore _store, bytes32 id, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.updateInField(_tableId, _keyTuple, 8, _index * 1, bytes((_slice)));
  }

  /** Get victimAnswerTwo */
  function getVictimAnswerTwo(bytes32 id) internal view returns (string memory victimAnswerTwo) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 9);
    return (string(_blob));
  }

  /** Get victimAnswerTwo (using the specified store) */
  function getVictimAnswerTwo(IStore _store, bytes32 id) internal view returns (string memory victimAnswerTwo) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 9);
    return (string(_blob));
  }

  /** Set victimAnswerTwo */
  function setVictimAnswerTwo(bytes32 id, string memory victimAnswerTwo) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.setField(_tableId, _keyTuple, 9, bytes((victimAnswerTwo)));
  }

  /** Set victimAnswerTwo (using the specified store) */
  function setVictimAnswerTwo(IStore _store, bytes32 id, string memory victimAnswerTwo) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.setField(_tableId, _keyTuple, 9, bytes((victimAnswerTwo)));
  }

  /** Get the length of victimAnswerTwo */
  function lengthVictimAnswerTwo(bytes32 id) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    uint256 _byteLength = StoreSwitch.getFieldLength(_tableId, _keyTuple, 9, getSchema());
    return _byteLength / 1;
  }

  /** Get the length of victimAnswerTwo (using the specified store) */
  function lengthVictimAnswerTwo(IStore _store, bytes32 id) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    uint256 _byteLength = _store.getFieldLength(_tableId, _keyTuple, 9, getSchema());
    return _byteLength / 1;
  }

  /** Get an item of victimAnswerTwo (unchecked, returns invalid data if index overflows) */
  function getItemVictimAnswerTwo(bytes32 id, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getFieldSlice(_tableId, _keyTuple, 9, getSchema(), _index * 1, (_index + 1) * 1);
    return (string(_blob));
  }

  /** Get an item of victimAnswerTwo (using the specified store) (unchecked, returns invalid data if index overflows) */
  function getItemVictimAnswerTwo(IStore _store, bytes32 id, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getFieldSlice(_tableId, _keyTuple, 9, getSchema(), _index * 1, (_index + 1) * 1);
    return (string(_blob));
  }

  /** Push a slice to victimAnswerTwo */
  function pushVictimAnswerTwo(bytes32 id, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.pushToField(_tableId, _keyTuple, 9, bytes((_slice)));
  }

  /** Push a slice to victimAnswerTwo (using the specified store) */
  function pushVictimAnswerTwo(IStore _store, bytes32 id, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.pushToField(_tableId, _keyTuple, 9, bytes((_slice)));
  }

  /** Pop a slice from victimAnswerTwo */
  function popVictimAnswerTwo(bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.popFromField(_tableId, _keyTuple, 9, 1);
  }

  /** Pop a slice from victimAnswerTwo (using the specified store) */
  function popVictimAnswerTwo(IStore _store, bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.popFromField(_tableId, _keyTuple, 9, 1);
  }

  /** Update a slice of victimAnswerTwo at `_index` */
  function updateVictimAnswerTwo(bytes32 id, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.updateInField(_tableId, _keyTuple, 9, _index * 1, bytes((_slice)));
  }

  /** Update a slice of victimAnswerTwo (using the specified store) at `_index` */
  function updateVictimAnswerTwo(IStore _store, bytes32 id, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.updateInField(_tableId, _keyTuple, 9, _index * 1, bytes((_slice)));
  }

  /** Get victimAnswerThree */
  function getVictimAnswerThree(bytes32 id) internal view returns (string memory victimAnswerThree) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 10);
    return (string(_blob));
  }

  /** Get victimAnswerThree (using the specified store) */
  function getVictimAnswerThree(IStore _store, bytes32 id) internal view returns (string memory victimAnswerThree) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 10);
    return (string(_blob));
  }

  /** Set victimAnswerThree */
  function setVictimAnswerThree(bytes32 id, string memory victimAnswerThree) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.setField(_tableId, _keyTuple, 10, bytes((victimAnswerThree)));
  }

  /** Set victimAnswerThree (using the specified store) */
  function setVictimAnswerThree(IStore _store, bytes32 id, string memory victimAnswerThree) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.setField(_tableId, _keyTuple, 10, bytes((victimAnswerThree)));
  }

  /** Get the length of victimAnswerThree */
  function lengthVictimAnswerThree(bytes32 id) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    uint256 _byteLength = StoreSwitch.getFieldLength(_tableId, _keyTuple, 10, getSchema());
    return _byteLength / 1;
  }

  /** Get the length of victimAnswerThree (using the specified store) */
  function lengthVictimAnswerThree(IStore _store, bytes32 id) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    uint256 _byteLength = _store.getFieldLength(_tableId, _keyTuple, 10, getSchema());
    return _byteLength / 1;
  }

  /** Get an item of victimAnswerThree (unchecked, returns invalid data if index overflows) */
  function getItemVictimAnswerThree(bytes32 id, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getFieldSlice(_tableId, _keyTuple, 10, getSchema(), _index * 1, (_index + 1) * 1);
    return (string(_blob));
  }

  /** Get an item of victimAnswerThree (using the specified store) (unchecked, returns invalid data if index overflows) */
  function getItemVictimAnswerThree(IStore _store, bytes32 id, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getFieldSlice(_tableId, _keyTuple, 10, getSchema(), _index * 1, (_index + 1) * 1);
    return (string(_blob));
  }

  /** Push a slice to victimAnswerThree */
  function pushVictimAnswerThree(bytes32 id, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.pushToField(_tableId, _keyTuple, 10, bytes((_slice)));
  }

  /** Push a slice to victimAnswerThree (using the specified store) */
  function pushVictimAnswerThree(IStore _store, bytes32 id, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.pushToField(_tableId, _keyTuple, 10, bytes((_slice)));
  }

  /** Pop a slice from victimAnswerThree */
  function popVictimAnswerThree(bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.popFromField(_tableId, _keyTuple, 10, 1);
  }

  /** Pop a slice from victimAnswerThree (using the specified store) */
  function popVictimAnswerThree(IStore _store, bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.popFromField(_tableId, _keyTuple, 10, 1);
  }

  /** Update a slice of victimAnswerThree at `_index` */
  function updateVictimAnswerThree(bytes32 id, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.updateInField(_tableId, _keyTuple, 10, _index * 1, bytes((_slice)));
  }

  /** Update a slice of victimAnswerThree (using the specified store) at `_index` */
  function updateVictimAnswerThree(IStore _store, bytes32 id, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.updateInField(_tableId, _keyTuple, 10, _index * 1, bytes((_slice)));
  }

  /** Get verdict */
  function getVerdict(bytes32 id) internal view returns (string memory verdict) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 11);
    return (string(_blob));
  }

  /** Get verdict (using the specified store) */
  function getVerdict(IStore _store, bytes32 id) internal view returns (string memory verdict) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 11);
    return (string(_blob));
  }

  /** Set verdict */
  function setVerdict(bytes32 id, string memory verdict) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.setField(_tableId, _keyTuple, 11, bytes((verdict)));
  }

  /** Set verdict (using the specified store) */
  function setVerdict(IStore _store, bytes32 id, string memory verdict) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.setField(_tableId, _keyTuple, 11, bytes((verdict)));
  }

  /** Get the length of verdict */
  function lengthVerdict(bytes32 id) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    uint256 _byteLength = StoreSwitch.getFieldLength(_tableId, _keyTuple, 11, getSchema());
    return _byteLength / 1;
  }

  /** Get the length of verdict (using the specified store) */
  function lengthVerdict(IStore _store, bytes32 id) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    uint256 _byteLength = _store.getFieldLength(_tableId, _keyTuple, 11, getSchema());
    return _byteLength / 1;
  }

  /** Get an item of verdict (unchecked, returns invalid data if index overflows) */
  function getItemVerdict(bytes32 id, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getFieldSlice(_tableId, _keyTuple, 11, getSchema(), _index * 1, (_index + 1) * 1);
    return (string(_blob));
  }

  /** Get an item of verdict (using the specified store) (unchecked, returns invalid data if index overflows) */
  function getItemVerdict(IStore _store, bytes32 id, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getFieldSlice(_tableId, _keyTuple, 11, getSchema(), _index * 1, (_index + 1) * 1);
    return (string(_blob));
  }

  /** Push a slice to verdict */
  function pushVerdict(bytes32 id, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.pushToField(_tableId, _keyTuple, 11, bytes((_slice)));
  }

  /** Push a slice to verdict (using the specified store) */
  function pushVerdict(IStore _store, bytes32 id, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.pushToField(_tableId, _keyTuple, 11, bytes((_slice)));
  }

  /** Pop a slice from verdict */
  function popVerdict(bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.popFromField(_tableId, _keyTuple, 11, 1);
  }

  /** Pop a slice from verdict (using the specified store) */
  function popVerdict(IStore _store, bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.popFromField(_tableId, _keyTuple, 11, 1);
  }

  /** Update a slice of verdict at `_index` */
  function updateVerdict(bytes32 id, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.updateInField(_tableId, _keyTuple, 11, _index * 1, bytes((_slice)));
  }

  /** Update a slice of verdict (using the specified store) at `_index` */
  function updateVerdict(IStore _store, bytes32 id, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.updateInField(_tableId, _keyTuple, 11, _index * 1, bytes((_slice)));
  }

  /** Get the full data */
  function get(bytes32 id) internal view returns (GameData memory _table) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = StoreSwitch.getRecord(_tableId, _keyTuple, getSchema());
    return decode(_blob);
  }

  /** Get the full data (using the specified store) */
  function get(IStore _store, bytes32 id) internal view returns (GameData memory _table) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    bytes memory _blob = _store.getRecord(_tableId, _keyTuple, getSchema());
    return decode(_blob);
  }

  /** Set the full data using individual values */
  function set(
    bytes32 id,
    bytes32 crime,
    address player,
    bool isGuilty,
    string memory openingStatement,
    string memory closingStatement,
    string memory victimQuestionOne,
    string memory victimQuestionTwo,
    string memory victimQuestionThree,
    string memory victimAnswerOne,
    string memory victimAnswerTwo,
    string memory victimAnswerThree,
    string memory verdict
  ) internal {
    bytes memory _data = encode(
      crime,
      player,
      isGuilty,
      openingStatement,
      closingStatement,
      victimQuestionOne,
      victimQuestionTwo,
      victimQuestionThree,
      victimAnswerOne,
      victimAnswerTwo,
      victimAnswerThree,
      verdict
    );

    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.setRecord(_tableId, _keyTuple, _data);
  }

  /** Set the full data using individual values (using the specified store) */
  function set(
    IStore _store,
    bytes32 id,
    bytes32 crime,
    address player,
    bool isGuilty,
    string memory openingStatement,
    string memory closingStatement,
    string memory victimQuestionOne,
    string memory victimQuestionTwo,
    string memory victimQuestionThree,
    string memory victimAnswerOne,
    string memory victimAnswerTwo,
    string memory victimAnswerThree,
    string memory verdict
  ) internal {
    bytes memory _data = encode(
      crime,
      player,
      isGuilty,
      openingStatement,
      closingStatement,
      victimQuestionOne,
      victimQuestionTwo,
      victimQuestionThree,
      victimAnswerOne,
      victimAnswerTwo,
      victimAnswerThree,
      verdict
    );

    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.setRecord(_tableId, _keyTuple, _data);
  }

  /** Set the full data using the data struct */
  function set(bytes32 id, GameData memory _table) internal {
    set(
      id,
      _table.crime,
      _table.player,
      _table.isGuilty,
      _table.openingStatement,
      _table.closingStatement,
      _table.victimQuestionOne,
      _table.victimQuestionTwo,
      _table.victimQuestionThree,
      _table.victimAnswerOne,
      _table.victimAnswerTwo,
      _table.victimAnswerThree,
      _table.verdict
    );
  }

  /** Set the full data using the data struct (using the specified store) */
  function set(IStore _store, bytes32 id, GameData memory _table) internal {
    set(
      _store,
      id,
      _table.crime,
      _table.player,
      _table.isGuilty,
      _table.openingStatement,
      _table.closingStatement,
      _table.victimQuestionOne,
      _table.victimQuestionTwo,
      _table.victimQuestionThree,
      _table.victimAnswerOne,
      _table.victimAnswerTwo,
      _table.victimAnswerThree,
      _table.verdict
    );
  }

  /** Decode the tightly packed blob using this table's schema */
  function decode(bytes memory _blob) internal view returns (GameData memory _table) {
    // 53 is the total byte length of static data
    PackedCounter _encodedLengths = PackedCounter.wrap(Bytes.slice32(_blob, 53));

    _table.crime = (Bytes.slice32(_blob, 0));

    _table.player = (address(Bytes.slice20(_blob, 32)));

    _table.isGuilty = (_toBool(uint8(Bytes.slice1(_blob, 52))));

    // Store trims the blob if dynamic fields are all empty
    if (_blob.length > 53) {
      uint256 _start;
      // skip static data length + dynamic lengths word
      uint256 _end = 85;

      _start = _end;
      _end += _encodedLengths.atIndex(0);
      _table.openingStatement = (string(SliceLib.getSubslice(_blob, _start, _end).toBytes()));

      _start = _end;
      _end += _encodedLengths.atIndex(1);
      _table.closingStatement = (string(SliceLib.getSubslice(_blob, _start, _end).toBytes()));

      _start = _end;
      _end += _encodedLengths.atIndex(2);
      _table.victimQuestionOne = (string(SliceLib.getSubslice(_blob, _start, _end).toBytes()));

      _start = _end;
      _end += _encodedLengths.atIndex(3);
      _table.victimQuestionTwo = (string(SliceLib.getSubslice(_blob, _start, _end).toBytes()));

      _start = _end;
      _end += _encodedLengths.atIndex(4);
      _table.victimQuestionThree = (string(SliceLib.getSubslice(_blob, _start, _end).toBytes()));

      _start = _end;
      _end += _encodedLengths.atIndex(5);
      _table.victimAnswerOne = (string(SliceLib.getSubslice(_blob, _start, _end).toBytes()));

      _start = _end;
      _end += _encodedLengths.atIndex(6);
      _table.victimAnswerTwo = (string(SliceLib.getSubslice(_blob, _start, _end).toBytes()));

      _start = _end;
      _end += _encodedLengths.atIndex(7);
      _table.victimAnswerThree = (string(SliceLib.getSubslice(_blob, _start, _end).toBytes()));

      _start = _end;
      _end += _encodedLengths.atIndex(8);
      _table.verdict = (string(SliceLib.getSubslice(_blob, _start, _end).toBytes()));
    }
  }

  /** Tightly pack full data using this table's schema */
  function encode(
    bytes32 crime,
    address player,
    bool isGuilty,
    string memory openingStatement,
    string memory closingStatement,
    string memory victimQuestionOne,
    string memory victimQuestionTwo,
    string memory victimQuestionThree,
    string memory victimAnswerOne,
    string memory victimAnswerTwo,
    string memory victimAnswerThree,
    string memory verdict
  ) internal view returns (bytes memory) {
    uint40[] memory _counters = new uint40[](9);
    _counters[0] = uint40(bytes(openingStatement).length);
    _counters[1] = uint40(bytes(closingStatement).length);
    _counters[2] = uint40(bytes(victimQuestionOne).length);
    _counters[3] = uint40(bytes(victimQuestionTwo).length);
    _counters[4] = uint40(bytes(victimQuestionThree).length);
    _counters[5] = uint40(bytes(victimAnswerOne).length);
    _counters[6] = uint40(bytes(victimAnswerTwo).length);
    _counters[7] = uint40(bytes(victimAnswerThree).length);
    _counters[8] = uint40(bytes(verdict).length);
    PackedCounter _encodedLengths = PackedCounterLib.pack(_counters);

    return
      abi.encodePacked(
        crime,
        player,
        isGuilty,
        _encodedLengths.unwrap(),
        bytes((openingStatement)),
        bytes((closingStatement)),
        bytes((victimQuestionOne)),
        bytes((victimQuestionTwo)),
        bytes((victimQuestionThree)),
        bytes((victimAnswerOne)),
        bytes((victimAnswerTwo)),
        bytes((victimAnswerThree)),
        bytes((verdict))
      );
  }

  /** Encode keys as a bytes32 array using this table's schema */
  function encodeKeyTuple(bytes32 id) internal pure returns (bytes32[] memory _keyTuple) {
    _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));
  }

  /* Delete all data for given keys */
  function deleteRecord(bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    StoreSwitch.deleteRecord(_tableId, _keyTuple);
  }

  /* Delete all data for given keys (using the specified store) */
  function deleteRecord(IStore _store, bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = bytes32((id));

    _store.deleteRecord(_tableId, _keyTuple);
  }
}

function _toBool(uint8 value) pure returns (bool result) {
  assembly {
    result := value
  }
}
